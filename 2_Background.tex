%\section{Background and Related Work}
%\label{back}
%\subsection{Program Comprehension}

% \castor{It would be nice to have a table with the atom candidates
% similar to the one that appears in Gopstein et al. 2017.}

% The concept of program comprehension is central to software maintenance and feature development \cite{DBLP:conf/iwpc/TilleySP96}. Regardless of whether they are performing maintenance on legacy software or adding new features, programmers have to understand what the source code does before making any improvements. A natural consequence of this is that a programmer must also have in mind that other programmers (or their future selves) 
% %are going to have to
% will
% spend time trying to understand the code being currently developed before doing any work themselves.

% As program comprehension is regarded less as a systematic process than as an objective \cite{DBLP:journals/ibmsj/OHareT94}, there is no single approach or framework that is capable of yielding easily understandable programs. Factors such as problem domain, size and complexity of the code base, and available tools all vary significantly between different settings. These aspects, combined with differences between individuals, which can include experience, working memory capacity, and other cognitive traits, make it clear that program comprehension should be approached in different ways in different contexts. 

% However, one of the ways in which programs become less comprehensible occurs when programmers favor complicated syntactic constructs instead of using semantically equivalent versions---when these exist---that are potentially less complex. %allowed by the language or framework they are working with. 
% This can be a matter of personal taste, since different individuals might hold different opinions on whether a given syntax is difficult to understand. Nevertheless, it is possible to empirically investigate if there exist programming language constructs or idioms that are considerably harder to understand, leading readers of the code to frequently make incorrect predictions of its behavior. 

%\subsection{Atoms of Confusion}\label{sec:aoc}

\section{Related Work}

\label{back}

The concept of program comprehension is central to software maintenance and feature development \cite{DBLP:conf/iwpc/TilleySP96, DBLP:journals/ibmsj/OHareT94}. Atoms of confusion is an important field of program comprehension introduced by Gopstein et al. \cite{DBLP:conf/msr/GopsteinZFC18}, who defined them as small code patterns that can verifiably lead to misunderstandings. In addition, for a code pattern to be considered an atom, there must be some alternative pattern or language construct that is functionally equivalent and less likely to cause confusion. One example that occurs in many programming languages is the Change of Literal Encoding. For instance, the \clang code statement \lstinline{printf("\%d", 013);} 
often leads programmers to predict the output to be \texttt{13}, even though the correct answer is \texttt{11}. This occurs because a leading \texttt{0} in a numerical literal indicates that the number is in base \texttt{8}, a fact that is not only unknown to less experienced programmers, but misleading even for seasoned developers. After formulating a list of 19 atom candidates, Gopstein et al. \cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} were able to identify 15 code idioms and language constructs that present a statistically significant difference in comparative answer correctness when each of the 15 atoms was removed. The least confusing atom showed a 14\% boost in prediction accuracy when the atom was removed, whereas the most confusing one showed a 60\% accuracy increase. In a different work, Gopstein et al. \cite{DBLP:conf/msr/GopsteinZFC18} presented the results of a comprehensive research on the incidence of atoms of confusion in the wild, considering open-source projects written in \clang and \cpplang~programming languages.


%Their work laid an empirical framework to identify such atoms. In summary, the basic approach to determine whether a code pattern is an atom involves: (i) identifying a set of atom candidates; (ii) identifying alternative constructs to these atom candidates; (iii) building a set of small programs that each contain a single atom candidate; (iv) building different versions of these programs where the atom candidates were removed and which employ the aforementioned alternative constructs; (v) in an experiment or semi-experiment, presenting subjects with the two versions of the programs for each atom candidate and asking subjects to predict their outputs; (vi) statistically comparing the performance of the subjects.
%By having subjects evaluate code where in the expected output relied exclusively on evaluating the result of previously known confusing programs that had been written in \clang or \cpplang, and asking the participants to predict the output of a set of code snippets where the atoms had been removed, the authors were able to isolate and measure the impact of such confusing atoms. 

These previous studies~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17,DBLP:conf/msr/GopsteinZFC18}
have a great influence in our work. Even though JavaScript is a dynamic language that differs from \clang in a variety of aspects, it also has a number of constructs in common. In addition, the imperative aspects of the language are syntactically similar to \clang, e.g., assignments, conditional expressions, \texttt{if}-statements, pre and post increments and decrements, among others. On the one hand, this means that some of the atoms of confusion that exist in \clang programs may also occur in JavaScript code. On the other hand, differences between the languages and the surrounding programming cultures may lead to code patterns that are atoms of confusion in one language not being atoms in the other one.
%Although JavaScript allows us to program in different paradigms from the one C follows, most of the JavaScript code found in popular repositories are written under the imperative paradigm. Also, both languages share many syntactical rules, which allows us to replicate some of the C atoms in JavaScript.

%The first study of Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} inspired other studies to further investigate the impact of atoms of confusion on code comprehension.

Oliveira et al.~\cite{TheEyesDoNotLie} conducted an experiment using an eye-tracker with 30 participants involving three atoms in \clang. They found that code with atoms of confusion requires more time from participants to predict the output and more visual effort to comprehend. Gopstein et al., in another paper~\cite{ThinkingAloud} further explored the original atoms by additionally conducting interviews and having programmers discuss among themselves the studied atoms. The authors argue that this method is important to complement a quantitative analysis. Indeed, their study revealed findings such as a \textit{``correct evaluation of an atom might not mean that a programmer understood its meaning''}. We follow a similar approach as we augment our quantitative analysis with interviews.

%Gopstein et al. also influenced researchers to look into atoms in languages other than \clang and \cpplang.
Langhout and Aniche~\cite{Langhout:2021:ACJ} derived a set of 14 atoms for Java and performed an experiment with 132 students. They found that participants are more likely to make mistakes (ranging from 2.7 up to 56 times) when atoms are present in half of their studied atoms. Castor~\cite{castor2018} presented a preliminary catalog of six atom candidates for the Swift programming language. Unlike JavaScript, in Swift, most of the atoms identified by Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} are avoided by construction, e.g., it does not have assignments as values, increment operators, or macros. 
%The paper also presents a structured definition for what it means for a code pattern to be an atom of confusion and a set of general principles to help in the identification of new atoms.

Medeiros et al. \cite{DBLP:journals/ese/MedeirosLAAKRG19} analyzed 50 open source projects written in the \clang language with the goal of evaluating 12 code patterns called ``misunderstanding patterns'' by the authors. Many of these misunderstanding patterns are either atoms of confusion or atom candidates~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}. This study shows that these patterns are prevalent; among these 50 projects, there are more than 109K occurrences of misunderstanding patterns. 
In order to gauge the relevance of these misunderstanding patterns, the authors sent 35 pull requests removing occurrences of these patterns to randomly-selected open source projects. The authors of the study received feedback for 21 of these pull requests and the maintainers of the projects accepted 8 of them (22.86\%). 
%The authors also analyzed 36 coding style guides from these projects, but found few guidelines specifically addressing misunderstanding patterns. 

% Para compreender a relevância desses misunderstanding patterns os autores enviaram 35 pull requests selecionados aleatoriamente, para remover as ocorrências desses padrões encontrados no código dos projetos avaliados. Os autores receberam feedback para 21 pull requests, e os desenvolvedores aceitaram 8 pull requests (38\%). Os autores também analisaram 36 Guidelines dos open-source projects provide for developers regarding misunderstanding code patterns.

% Castor~\cite{castor2018} presented a preliminary catalog of six atom candidates for the Swift programming language. Unlike JavaScript, in Swift most of the atoms identified by Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} are avoided by construction, e.g., it does not have assignments as values, increment operators, or macros. The paper also presents a structured definition for what it means for a code pattern to be an atom of confusion and a set of general principles to help in the identification of new atoms. 

%Castor \cite{castor2018} apresentou um catalógo preliminar de átomos de confusão na linguagem de programação Swift. O autor identificou 6 estruturas candidatas a átomos de confusão em Swift. Foram omitidos os candidatos que tinham uma correspondência direta com os átomos previamente identificados por Gopstein et al. \cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}.

%% According to Arnaoudova et al.~\cite{Arnaoudova:2016:LAW}, Linguistic Antipatterns (LA) are \textit{``recurring poor practices in the naming, documentation, and choice of identifiers in the implementation of an entity [..] that may impair program understanding''}. These antipatterns are design issues that go against developer's  intuition about a program, for example, a \texttt{set} method that returns a result. Similarly to atoms of confusion, LAs occur at the source code level and hinder code readability. Differently from atoms of confusion, LAs are more akin to design principles than code idioms. In addition, they are language-agnostic, unlike atoms of confusion.

Santos and Gerosa~\cite{Santos:2018:ICP} analyze the impact of eleven coding practices on program readability. However, most of the practices analyzed in their study relate to code formatting, instead of language constructs or idioms that might introduce misunderstanding. We borrow from their research the methodology for collecting the practitioners opinion about code snippets preference.


%% \castor{Provavelmente devemos reduzir o espaço tomado pelos quatro trabalhos acima, a depender da existência de outros. O de Linguistic Antipatterns talvez até devesse sair.}
%% \rb{Incluir os trabalhos do grupo do Marcio Ribeiro e do Fernando Castor. Quais outros trabalhos deveriamos incluir aqui?}

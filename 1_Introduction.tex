\section{Introduction}
\label{intro}

% The source code of a program can be naively understood as a collection of sentences in a language that would be interpreted by a computer (or compiled into a lower level representation and then executed by a computer). Nonetheless, this understanding is far from being complete. While it is not possible to execute programs without writing them in a way that the machine is able to interpret, it is also very difficult to develop software that performs complex tasks if developers do not care about how easily other programmers are going to understand its source code \cite{DBLP:journals/cj/Knuth84}.

% \rb{acho que esse proximo paragrafo pode ser excluido}
% \diego{também acho}

% {\color{blue}That means programming should, in various ways, be regarded as an act of communication. In this context, the programmer is often faced with a dilemma. When initially confronted with a problem they have to solve, the programmer will proceed to employ their cognition into developing the logic of the solution, whilst simultaneously having to worry about writing ``syntactically correct'' code for the machine to parse and translate. The problem is that, during the time spent solving the problem and communicating with the computer, developers often do not have enough cognitive resources to also make considerations about whether their code is understandable by other programmers. Therefore, it takes a change of track to make the code easier to understand \cite{DBLP:books/daglib/0019908}. Not proceeding with such change of track is one of the reasons why ``confusing'' language constructs and idioms arise and remain in a program.}

Source code misunderstandings can occur due to diverse reasons.
For instance, a poorly understood requirement might lead to poorly implemented code.
An intricate algorithm may require extra time to be fully comprehended.
Besides that, programming languages can also be at fault
and specific syntax and semantics of a language can cause misunderstandings. The same applies to some code
idioms and stylistic choices~\cite{DBLP:conf/msr/GopsteinZFC18}.

% \diego{acho que o prox. parágrafo deve ser adaptado ou até removido}
% {\color{blue}A direct consequence of the presence of these idioms in the code base is that it becomes even more difficult to develop new features for the software. 
% According to Gopstein et al. \cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} ``\emph{the ability to understand pre-existing source code is one of the most important elements of a continuously successful software project}'', it follows that, if one cannot properly understand the \emph{purpose} and \emph{meaning} of a piece of code, they are not going to be able to build upon its existing parts.
% Other consequences of the presence of confusing code include: 
% (a) increased probability of bug introduction, due to a lack of proper understanding of what the program does; 
% and (b) loss of internal quality measures, such as cohesion and coupling. 
% This phenomenon usually leads to an architectural erosion. 
% All these situations, which usually compound each other, expose the necessity of developing recommendations, tools, and techniques that help developers to avoid writing confusing code, identify potentially confusing code, and transform confusing code into clear code. 
% Therefore, it is necessary to understand what programming language constructs and idioms might lead to code that is hard to understand.}

This research focus on existing JavaScript idioms that a previous 
research work have proved to introduce misunderstanding in \clang.
JavaScript the most widely used language for web development and the most often adopted language on GitHub~\cite{BugsJS:ICST}. At the same time, JavaScript is infamously known to be ``the worst most popular language in the world''.\footnote{\url{https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/preface.md}} It is a weakly typed language~\cite{DynamicBehaviorJS:PLDI} that provides object-oriented, functional, and imperative constructs~\cite{JS-CodeSmells:SCAM}, in addition to features such as run-time evaluation~\cite{BugsJS:ICST,ClientSideBugsJS:TSE}, and asynchronous operations. All these 
%diverse characteristics and capabilities
features combined make JavaScript source code fertile ground for errors~\cite{BugsJS:ICST,ClientSideBugsJS:TSE} and confusion~\cite{JSGoodParts:book}.

In particular, our research aims to help practitioners identify potentially confusing snippets of code and alternative snippets that can make the code clearer.
To achieve that, we investigate JavaScript idioms that
might negatively impact program understanding. These idioms correspond to a set of candidates for \emph{atoms of confusion} in
JavaScript---that is, small
pieces of code that hinder developers' understanding of the source code of a program
for which there are functionally equivalent alternatives that are easier
to understand~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}. For instance, consider
the pair of code snippets in Listing~\ref{fig:lst01} (adapted from \textsc{NervJS/taro}).
%for presentation purpose only). 
The code on the left-hand side of the figure contains two atoms of confusion discussed in previous work focusing on the \clang
language~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}: \emph{Logic as Control Flow} and \emph{Post-increment}. On the right-hand side, we present a cleaned version of the code, that is, without atoms of confusion. In the experiments of Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}, removing the atoms \emph{Logic as Control Flow} and \emph{Post-increment} improved the accuracy of program understanding tasks in  41\% and 34\%, respectively.

Recent work~\cite{DBLP:journals/ese/MedeirosLAAKRG19,DBLP:conf/sigsoft/GopsteinIYDZYC17,Langhout:2021:ACJ} has explored the impact of atoms of confusion on program understanding, and confirmed they negatively impact source code readability.
However, these previous studies focus exclusively on statically typed languages (e.g., \clang, \cpplang, and Java). However, JavaScript's programming culture differs from that of languages such as \clang and \cpplang, particularly due to the JavaScript's dynamic
capabilities and weaker type system. Thus, we may find that idioms and constructs that are atoms of confusion in those languages are not particularly difficult to understand for JavaScript programmers and vice-versa. Here we investigate a group of atom candidates
that stems from the Gopstein et al. study and detail additional JavaScript constructs
that might introduce misunderstanding---according to the opinion of JavaScript
developers. 

\begin{figure*}[thb]
\noindent\begin{minipage}{.45\textwidth}  
\begin{lstlisting}[language=JavaScript]
res = properties.reduce((s, b) => {
  b && s++
  return s
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=JavaScript]
res = properties.reduce((s, b) => {
  if(b) {
    s = s + 1
  }
  return s
}
\end{lstlisting}
\end{minipage}
\captionof{lstlisting}{Code snippet from \textsc{NervJS/taro} project. Line 2 on the left-hand side of the figure contains two
  atoms of confusion discussed in ~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}: \emph{Logic
  as Control Flow} and \emph{Post-increment}. On the right-hand side, we present an alternative implementation without atoms of confusion. We could simplify the code on the left-hand side even more, by using \texttt{filter} and \texttt{length} instead of the \texttt{reduce} recursive pattern (e.g., \texttt{res = properties.filter(p => p).length}).}\label{fig:lst01}
\end{figure*}

To understand whether an atom of confusion introduces misunderstandings,
we surveyed 140 JavaScript developers. In the survey, 
their task was to predict the output of short code
snippets, with half of them containing atoms of confusion. 
{\color{red}The number of correct answers for the
  \emph{cleaned version} of the code snippets for seven (out of nine)
  atom candidates is at least 15\% higher than the corresponding
  \emph{confuse version
  of the code snippet (i.e., with an atom candidate). The presence of an atom candidate
  might also affects the time necessary for submitting a correct answer.}
  For instance, the presence of the Comma Operator atom increases
  the average time to predict the output by 65\%, though the output of snippets containing
  the Pre-Increment atom were correctly predicted 44\% faster.
  
  To learn more about the misunderstandings in the snippets used in the survey, we interviewed 15
  experienced professional developers. Participants considered the code snippets without
  the atom candidates easier to understand in 70\% of the cases,
  therefore corroborating the survey findings. The participants also discussed other 
  idioms that might lead developers to misunderstand JavaScript code.
  The occurrence of atoms in open-source repositories might reveal cases where developers
  should be more or less careful when writing code---and open the possibility to implement
  new program transformations for cleaning up confuse code. To identify such cases, we mined popular JavaScript projects
  from GitHub and found four atom candidates that are highly used in JavaScript
  code: the Implicit Predicate atom, for instance, occurs 19.89 times per KLOC of
  code.}


Altogether, the main contributions of this paper are:
\rb{revisar as contribuicoes quando o artigo estiver mais maduro. por enquanto, vamos ignorar esses bullets.}

\begin{itemize}
    \item A study about the impact of atoms of confusion on a
    dynamic language.
    \item A list of additional atoms of confusion addressing particular 
    JavaScript constructs and idioms.
    \item A library and infrastructure to mine atoms of confusion using 
    code queries (implemented in the .QL language). This library and 
    infrastructure are freely available and might help researchers and 
    practitioners to automate program analysis at a large scale.
\end{itemize}



% Our research aims to identify and characterize JavaScript \textit{atoms of confusion}: small pieces of code that hinder developers' understanding of the source code of a program~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}.
% Previous research has confirmed the negative impact of atoms of confusion when considering statically typed languages (e.g., \clang and \cpplang)~\cite{DBLP:journals/ese/MedeirosLAAKRG19, DBLP:conf/msr/GopsteinZFC18}.

% Recent works have explored the impact of \emph{atoms of confusion}~\cite{DBLP:journals/ese/MedeirosLAAKRG19,DBLP:conf/sigsoft/He19,DBLP:conf/msr/GopsteinZFC18} on program understanding.
% Atoms of confusion correspond to small pieces of code that hinder developers' understanding of the source code of a program. 
% Previous research has confirmed the negative impact of atoms of confusion when considering statically typed languages (e.g., \clang and \cpplang)~\cite{DBLP:journals/ese/MedeirosLAAKRG19,DBLP:conf/msr/GopsteinZFC18}.

% In this work, to the best of our knowledge, we are the first to explore this issue in the context of a dynamically typed language (JavaScript), answering the following research questions:
% \emph{How do JavaScript developers  identify atoms of confusion as contributing to program misunderstanding?}
% \emph{What is the impact of atoms of confusion on misunderstanding JavaScript code?},
% and \emph{What is the frequency of occurrence of  atoms of confusion in practice?} 
% To answer these research questions, we conduct this investigation using a mixed-methods approach, involving a survey, a set of interviews, and an activity of mining source code repositories. Altogether, the main contributions of this paper are

% \rb{revisar as contribuicoes quando o artigo estiver mais maduro. por enquanto, vamos ignorar esses bullets.}

% \begin{itemize}
%     \item A first study about the impact of atoms of confusion on a
%     dynamic language. {\color{red}present some of the results here.}
%     \item A library and infrastructure to mine atoms of confusion using 
%     code queries (implemented in the .QL language). This library and 
%     infrastructure is freely available and might help other researcher and 
%     practitioners to automate program analysis at a large scale. 
%     \item A list of additional atoms of confusion addressing particular 
%     JavaScript constructs and idioms. {\color{red}present some insights 
%     about these additional atoms here}
% \end{itemize}

\section{Introduction}
\label{intro}

% The source code of a program can be naively understood as a collection of sentences in a language that would be interpreted by a computer (or compiled into a lower level representation and then executed by a computer). Nonetheless, this understanding is far from being complete. While it is not possible to execute programs without writing them in a way that the machine is able to interpret, it is also very difficult to develop software that performs complex tasks if developers do not care about how easily other programmers are going to understand its source code \cite{DBLP:journals/cj/Knuth84}.

% \rb{acho que esse proximo paragrafo pode ser excluido}
% \diego{também acho}

% {\color{blue}That means programming should, in various ways, be regarded as an act of communication. In this context, the programmer is often faced with a dilemma. When initially confronted with a problem they have to solve, the programmer will proceed to employ their cognition into developing the logic of the solution, whilst simultaneously having to worry about writing ``syntactically correct'' code for the machine to parse and translate. The problem is that, during the time spent solving the problem and communicating with the computer, developers often do not have enough cognitive resources to also make considerations about whether their code is understandable by other programmers. Therefore, it takes a change of track to make the code easier to understand \cite{DBLP:books/daglib/0019908}. Not proceeding with such change of track is one of the reasons why ``confusing'' language constructs and idioms arise and remain in a program.}

Source code misunderstandings can occur due to diverse reasons.
A poorly understood requirement might lead to poorly implemented code.
An intricate algorithm may require extra time to be fully comprehended.
Nevertheless, programming languages can also be at fault.
Specific syntax and semantics of a language can cause misunderstandings. The same applies to some code idioms and stylistic choices~\cite{DBLP:conf/msr/GopsteinZFC18}.

% \diego{acho que o prox. parágrafo deve ser adaptado ou até removido}
% {\color{blue}A direct consequence of the presence of these idioms in the code base is that it becomes even more difficult to develop new features for the software. 
% According to Gopstein et al. \cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} ``\emph{the ability to understand pre-existing source code is one of the most important elements of a continuously successful software project}'', it follows that, if one cannot properly understand the \emph{purpose} and \emph{meaning} of a piece of code, they are not going to be able to build upon its existing parts.
% Other consequences of the presence of confusing code include: 
% (a) increased probability of bug introduction, due to a lack of proper understanding of what the program does; 
% and (b) loss of internal quality measures, such as cohesion and coupling. 
% This phenomenon usually leads to an architectural erosion. 
% All these situations, which usually compound each other, expose the necessity of developing recommendations, tools, and techniques that help developers to avoid writing confusing code, identify potentially confusing code, and transform confusing code into clear code. 
% Therefore, it is necessary to understand what programming language constructs and idioms might lead to code that is hard to understand.}

JavaScript is the most widely used language for web development and the most often adopted language on GitHub~\cite{BugsJS:ICST}. At the same time, JavaScript is infamously known to be ``the worst most popular language in the world''\footnote{https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/preface.md}. It is a weakly typed language~\cite{DynamicBehaviorJS:PLDI} that provides object-oriented, functional, and imperative constructs~\cite{JS-CodeSmells:SCAM}, in addition to features such as run-time evaluation~\cite{BugsJS:ICST,ClientSideBugsJS:TSE}, and asynchronous operations. All these 
%diverse characteristics and capabilities
features combined make JavaScript source code fertile ground for errors~\cite{BugsJS:ICST,ClientSideBugsJS:TSE} and confusion~\cite{JSGoodParts:book}.

Our research aims to help practitioners identify potentially confusing snippets of code, so that
developers could replace them with clearer code.
To achieve that, we investigate {\color{red}XYZ} JavaScript idioms that
might compromize program understanding. These idioms correspond to a set of candidates for \emph{atoms of confusion} in
JavaScript---that is, small
pieces of code that hinder developers' understanding of the source code of a program
for which there are functionally equivalent alternatives that are easier
to understand~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}. \castor{I think it would be really nice to have an example here. Maybe even a figure with a left-hand and a right-hand side. What do you say? If yes, I
'd go for post increment or assignment as value. If not a figure, the text could be as follow: An example of atom of confusion identified by previous work~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} is the use \texttt{if} statements without the accompanying curly braces. The alternative, in this case, is simply to always use the curly braces.}
Among the atoms in this work, X are shared between JavaScript and \clang/\cpplang (e.g., pre/post-increment), while Y others are specific to JavaScript, e.g., the atom Assignment as Value.
Recent work~\cite{DBLP:journals/ese/MedeirosLAAKRG19,DBLP:conf/sigsoft/GopsteinIYDZYC17} has
already explored the impact of atoms of confusion on program understanding,
and confirmed they negatively impact source code understandability.
However, they were constrained to statically typed languages (e.g., C and C++).
To the best of our knowledge, we are the first to explore atoms of confusion
in the context of a dynamically typed language (JavaScript).\castor{Review the number of atoms, X, and Y.}


To understand whether an atom of confusion introduces misunderstandings, we surveyed 140 developers from the Reddit community. Their task was to predict the output of short snippets of code, with half of them containing atoms of confusion. We found an improvement of at least 15\% in the correct answers when removing the confusing code for seven atoms (out of 9 atoms). The presence of the Comma Operator atom, for instance, can increase the average time to predict the output by 65\%, while the behavior of snippets containing the Pre-Increment atom were predicted 44\% faster.  An atom's presence---or lack of---in open-source repositories may reveal cases where developers should be more or less careful when writing code. To identify such cases, we mined the 100 most popular JavaScript projects from GitHub and found a total of X atoms in the analyzed projects. To learn more about the misunderstandings in the snippets used in the survey, we interviewed 15 experienced professional developers. Participants preferred code snippets \textit{without} an atom in 70\% of the cases, therefore corroborating to the survey findings. During the MSR and interview studies, we also explored additional atom candidates that are specific to the
JavaScript language. 


Altogether, the main contributions of this paper are:
\rb{revisar as contribuicoes quando o artigo estiver mais maduro. por enquanto, vamos ignorar esses bullets.}

\begin{itemize}
    \item A study about the impact of atoms of confusion on a
    dynamic language.
    \item A list of additional atoms of confusion addressing particular 
    JavaScript constructs and idioms.
    \item A library and infrastructure to mine atoms of confusion using 
    code queries (implemented in the .QL language). This library and 
    infrastructure are freely available and might help researchers and 
    practitioners to automate program analysis at a large scale.
\end{itemize}



% Our research aims to identify and characterize JavaScript \textit{atoms of confusion}: small pieces of code that hinder developers' understanding of the source code of a program~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}.
% Previous research has confirmed the negative impact of atoms of confusion when considering statically typed languages (e.g., \clang and \cpplang)~\cite{DBLP:journals/ese/MedeirosLAAKRG19, DBLP:conf/msr/GopsteinZFC18}.

% Recent works have explored the impact of \emph{atoms of confusion}~\cite{DBLP:journals/ese/MedeirosLAAKRG19,DBLP:conf/sigsoft/He19,DBLP:conf/msr/GopsteinZFC18} on program understanding.
% Atoms of confusion correspond to small pieces of code that hinder developers' understanding of the source code of a program. 
% Previous research has confirmed the negative impact of atoms of confusion when considering statically typed languages (e.g., \clang and \cpplang)~\cite{DBLP:journals/ese/MedeirosLAAKRG19,DBLP:conf/msr/GopsteinZFC18}.

% In this work, to the best of our knowledge, we are the first to explore this issue in the context of a dynamically typed language (JavaScript), answering the following research questions:
% \emph{How do JavaScript developers  identify atoms of confusion as contributing to program misunderstanding?}
% \emph{What is the impact of atoms of confusion on misunderstanding JavaScript code?},
% and \emph{What is the frequency of occurrence of  atoms of confusion in practice?} 
% To answer these research questions, we conduct this investigation using a mixed-methods approach, involving a survey, a set of interviews, and an activity of mining source code repositories. Altogether, the main contributions of this paper are

% \rb{revisar as contribuicoes quando o artigo estiver mais maduro. por enquanto, vamos ignorar esses bullets.}

% \begin{itemize}
%     \item A first study about the impact of atoms of confusion on a
%     dynamic language. {\color{red}present some of the results here.}
%     \item A library and infrastructure to mine atoms of confusion using 
%     code queries (implemented in the .QL language). This library and 
%     infrastructure is freely available and might help other researcher and 
%     practitioners to automate program analysis at a large scale. 
%     \item A list of additional atoms of confusion addressing particular 
%     JavaScript constructs and idioms. {\color{red}present some insights 
%     about these additional atoms here}
% \end{itemize}

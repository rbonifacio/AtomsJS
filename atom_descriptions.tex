

\footnote{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions\_and\_Operators}

\cite{Alves:2022:BPS}

% Please add the following required packages to your document preamble:
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}
\begin{table}[]
    \begin{tiny}
    \begin{tabular}{llll}
    \hline
    Atom Name                                                                  & Description                                                                                                                                                                                                                                                                                                                              & Obfuscated                                                                                                       & Clean                                                                                                                                     \\ \hline
    \begin{tabular}[c]{@{}l@{}}Change of Literal\\ Encoding\end{tabular}       & \begin{tabular}[c]{@{}l@{}}All numbers are stored as binary, but for convenience we represent numbers in decimal, hex, or octal.\\ Depending on the circumstance, certain representations are more understandable.\end{tabular}                                                                                                          & \begin{tabular}[c]{@{}l@{}}let V1 = 013\\ console.log(V1)\end{tabular}                                           & \begin{tabular}[c]{@{}l@{}}let V1 = 11\\ console.log(V1)\end{tabular}                                                                     \\
    Logic as Control Flow                                                      & \begin{tabular}[c]{@{}l@{}}Traditionally, the \&\& and || operators are used for logical conjunction and disjunction, respectively. Due to\\ short-circuiting, they can also be used for conditional execution.\end{tabular}                                                                                                             & V1 \&\& F2();                                                                                                    & if (V1) \{ F2() \};                                                                                                                       \\
    Assignment as Value                                                        & \begin{tabular}[c]{@{}l@{}}The assignment expression changes the state of the program when it executes, however it also returns a\\ value. When reading an assignment expression people may forget one of the two effects of the expression\end{tabular}                                                                                 & V1 = V2 = 3                                                                                                      & \begin{tabular}[c]{@{}l@{}}V2 = 3\\ V1 = V2\end{tabular}                                                                                  \\
    \begin{tabular}[c]{@{}l@{}}Pre-Increment /\\ Decrement\end{tabular}        & \begin{tabular}[c]{@{}l@{}}Similar to post-increment/decrement, these operators change a variableâ€™s value by one. In contrast to the\\ other operators, pre-increment/decrement first update the variable then return the new value.\end{tabular}                                                                                        & V1 = ++V2                                                                                                        & \begin{tabular}[c]{@{}l@{}}V2 += 1\\ V1 = V2\end{tabular}                                                                                 \\
    \begin{tabular}[c]{@{}l@{}}Post-Increment /\\ Decrement\end{tabular}       & \begin{tabular}[c]{@{}l@{}}The post-increment and decrement operators change the value of their operands by 1 and return the original\\ value. Confusion arises because the value of the expression is different from the value of the variable.\end{tabular}                                                                            & V1 = V2++                                                                                                        & \begin{tabular}[c]{@{}l@{}}V1 = V2\\ V2 += 1\end{tabular}                                                                                 \\
    Type Conversion                                                            & \begin{tabular}[c]{@{}l@{}}The C compiler will often implicitly convert types when there is a mismatch. Sometimes this conversion also\\ results in a different outcome than a reader expects\end{tabular}                                                                                                                               & \{\} + 4                                                                                                         & \{\}.toString() + (4).toString()                                                                                                          \\
    Conditional Operator                                                       & \begin{tabular}[c]{@{}l@{}}The conditional operator is the only ternary operator in C, and functions similarly to an if/else block. However,\\ it is an expression for which the value is that of the executed branch.\end{tabular}                                                                                                      & V2 = (V1==3)?2:V2                                                                                                & \begin{tabular}[c]{@{}l@{}}if (V1 == 3) \{ \\   V2 = 2;\\ \\ \}\end{tabular}                                                              \\
    Comma Operator                                                             & \begin{tabular}[c]{@{}l@{}}The comma operator is used to sequence series of computations. Whether due to its eccentricity, or its odd\\ precedence, the comma operator is commonly misinterpreted.\end{tabular}                                                                                                                          & V3 = (V1 += 1; V1)                                                                                               & \begin{tabular}[c]{@{}l@{}}V1 += 1;\\ V3 = V1;\end{tabular}                                                                               \\
    Implicit Predicate                                                         & \begin{tabular}[c]{@{}l@{}}The semantics of a predicate are easily mistaken. The most common example happens when assignment is\\ used inside a predicate or when a success state is represented as 0.\end{tabular}                                                                                                                      & if (4 \% 2)                                                                                                      & if (4 \% 2 != 0)                                                                                                                          \\
    Repurposed Variables                                                       & When a variable is used in different roles in a program, its current meaning can be difficult to follow                                                                                                                                                                                                                                  & \begin{tabular}[c]{@{}l@{}}let n = 1;\\ n = "OK";\end{tabular}                                                   & \begin{tabular}[c]{@{}l@{}}let n = 1;\\ let s = "OK";\end{tabular}                                                                        \\
    Omitted Curly Braces                                                       & When control statements omit curly braces, the scope of their influence can be difficult to discern                                                                                                                                                                                                                                      & if (V) F(); G();                                                                                                 & if (V) \{F();\} G();                                                                                                                      \\
    \begin{tabular}[c]{@{}l@{}}Infix Operator \\ Precedence\end{tabular}       & \begin{tabular}[c]{@{}l@{}}JavaScript has more than 40 operators, the majority of them infix, each in one of 17 precedence levels with either right or left associativity. Most\\ programmers know only a functional subset of these rules.\end{tabular}                                                                                 & 0 \&\& 1 || 2                                                                                                    & (0 \&\& 1) || 2                                                                                                                           \\
    Arithmetic as Logic                                                        & \begin{tabular}[c]{@{}l@{}}Arithmetic operators are capable of mimicking any predicate formulated with logical operators. Arithmetic,\\ however, implies a non-boolean range, which may be confusing to a reader\end{tabular}                                                                                                            & (V1-3) * (V2-4)                                                                                                  & V1!=3 \&\& V2!=4                                                                                                                          \\
    Constant Variables                                                         & \begin{tabular}[c]{@{}l@{}}Constant variables are a layer of abstraction that emphasize a concept rather than a particular value itself.\\ When trying to hand evaluate a piece of code having a layer of indirection can obscure the value of the data.\end{tabular}                                                                    & \begin{tabular}[c]{@{}l@{}}let V1 = 5\\ console.log(V1)\end{tabular}                                             & console.log(5)                                                                                                                            \\
    \begin{tabular}[c]{@{}l@{}}Dead, Unreachable,\\ Repeated\end{tabular}      & Redundant code is executed to no functional effect, but its appearance may imply that meaningful changes are being made                                                                                                                                                                                                                  & \begin{tabular}[c]{@{}l@{}}V1 = 1;\\ V1 = 2;\end{tabular}                                                        & V1 = 2;                                                                                                                                   \\
    \begin{tabular}[c]{@{}l@{}}Lack of Indentation, \\ no Braces\end{tabular}  & \begin{tabular}[c]{@{}l@{}}Block delimiters and indentation are very important to understand nested structures in programs. If block delimiters are missing and\\ indentation is incorrect, developers may misunderstand the nested structure of the program.\end{tabular}                                                               & \begin{tabular}[c]{@{}l@{}}if (V1)\\     if (V2) \\         V3 = V3 + 2;\\ else \\     V3 = V3 - 1;\end{tabular} & \begin{tabular}[c]{@{}l@{}}if (V1) \{\\     if (V2) \{ V3 = V3 + 2; \}\\     else \{ V3 = V3 - 1; \}\\ \}\end{tabular}                    \\
    \begin{tabular}[c]{@{}l@{}}Lack of Indentation,\\ with Braces\end{tabular} & \begin{tabular}[c]{@{}l@{}}Similar to Lack of Indentation, no Braces, but the block delimiters are present. The lack of indentation still has the potential to cause\\ confusion.\end{tabular}                                                                                                                                           & \begin{tabular}[c]{@{}l@{}}if (V1) \{\};\\     V1 = V1 - 1;\end{tabular}                                         & \begin{tabular}[c]{@{}l@{}}if (V1) \{\};\\ V1 = V1 - 1;\end{tabular}                                                                      \\
    \begin{tabular}[c]{@{}l@{}}Automatic Semicolon\\ Insertion\end{tabular}    & \begin{tabular}[c]{@{}l@{}}Semicolons in JavaScript are optional in some contexts. However, some cases where semicolons are optional can confuse the JavaScript\\ parser. This may lead to surprising behavior.\end{tabular}                                                                                                             & \begin{tabular}[c]{@{}l@{}}let V1 = 9\\ (console.log(V1))\end{tabular}                                           & \begin{tabular}[c]{@{}l@{}}let V1 = 9;\\ (console.log(V1));\end{tabular}                                                                  \\
    Property Access                                                            & \begin{tabular}[c]{@{}l@{}}Object properties can be accessed using the dot (".") notation used in most object oriented languages and also using notation similar to \\ how elements in collections like dictionaries and maps are accessed in other languages. The latter is much less popular than the former.\end{tabular}             & \begin{tabular}[c]{@{}l@{}}let V1 = \{P1:0, P2:5 \}\\ V1{[}'P1'{]} = 9;\end{tabular}                             & \begin{tabular}[c]{@{}l@{}}let V2 = \{P3:0, P4:5 \}\\ V2{[}'P3'{]} = 9;\end{tabular}                                                      \\
    Arrow Function                                                             & The usage of arrow function notation, instead of the more traditional JavaScript notations for anonymous functions.                                                                                                                                                                                                                      & \begin{tabular}[c]{@{}l@{}}let V1 = x =\textgreater x * x * x;\\ let V2 = V1(5);\end{tabular}                    & \begin{tabular}[c]{@{}l@{}}let V3 = (x) =\textgreater \{ \\   return x * x * x; \\ \}\\ let V4 = V3(5);\end{tabular}                      \\
    Array Spread                                                               & \begin{tabular}[c]{@{}l@{}}Spread facilitates copying, extracting elements and concatenating arrays. Some caveats exist as the copying is shallow so this can \\ cause misunderstanding between programmers.\end{tabular}                                                                                                                & \begin{tabular}[c]{@{}l@{}}let V1 = {[}1,2{]};\\ let V2 = {[}5,6{]};\\ V3 = {[}...V1, ...V2{]}\end{tabular}      & \begin{tabular}[c]{@{}l@{}}let V1 = {[}1,2{]};\\ let V2 = {[}5,6{]};\\ V3 = {[}V1{[}0{]}, V1{[}1{]}, V2{[}0{]}, V2{[}1{]}{]}\end{tabular} \\
    Object Spread                                                              & \begin{tabular}[c]{@{}l@{}}Similar to the spread in arrays, but with slightly more complex semantics because it may lead to the values of properties being\\ overwritten if properties with the same names exist in two objects combined by means of spread.\end{tabular}                                                                & \begin{tabular}[c]{@{}l@{}}let V1 = \{P1:5, P2:8, P3:13\};\\ let V2 = \{...V1, P3:99\};\end{tabular}             & \begin{tabular}[c]{@{}l@{}}let V1 = \{P1:5, P2:8, P3:13\};\\ let V2 = \{P3:99\};\\ V2.P1 = V1.P1\\ V2.P2 = V1.P2\end{tabular}             \\
    Array Destructuring                                                        & \begin{tabular}[c]{@{}l@{}}This feature provides an approach to perform a limited form of pattern matching based on the elements of an array. The syntax mixes the \\ introduction of new variables with array literals and is arguably less explicit than directly initializing new variables with array elements.\end{tabular}         & \begin{tabular}[c]{@{}l@{}}let {[}V2,,,V4{]} = {[}1,2,3,4{]};\\ console.log(V2, V4);\end{tabular}                & \begin{tabular}[c]{@{}l@{}}let V1 = {[}1,2,3,4{]};\\ console.log(V1{[}0{]}, V1{[}3{]});\end{tabular}                                      \\
    Object Destructuring                                                       & \begin{tabular}[c]{@{}l@{}}Similar to array destructuring, but uses the syntax associated with object literals to introduce new variables by matching their names with the \\ names of properties of the destructured object. This is less explicit than initializing the new variables with the values of said properties.\end{tabular} & \begin{tabular}[c]{@{}l@{}}let V1 = \{P1: 5\};\\ let \{P1, P2 = 20\} = V1;\end{tabular}                          & \begin{tabular}[c]{@{}l@{}}let V1 = \{P1: 5\};\\ let P1=V1.P1, P2=20;\end{tabular}                                                       
    \end{tabular}
\end{tiny}
    \end{table}
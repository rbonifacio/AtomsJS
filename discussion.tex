\section{Discussion}
\label{sec:discussion}

The results of the multiple studies we have conducted, combined and contrasted with previous work on atoms of confusion, provide an in-depth perspective on which code patterns tend to lead to confusion and which ones may require additional investigation. Across different studies, targeting different languages and groups of participants, these patterns have produced confusion, even in constrained scenarios without other interfering factors. 
Existing studies judge whether a code pattern is an atom of confusion or not by evaluating whether participants incorrectly predict the behavior of programs including that pattern significantly more often than the behavior of functionally equivalent programs that do not include it. According to this criterion, there are five atoms of confusion that have been confirmed in the studies of Langhout and Aniche~\cite{Langhout:2021:ACJ}, Gopstein and colleagues~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}, and at least one of the experiments we conducted, \textbf{Type Conversion}, \textbf{Change of Literal Encoding}, \textbf{Omitted Curly Braces}, \textbf{Pre-Increment}, and \textbf{Post-Increment}. They are small code patterns that have been shown to cause confusion for different samples, in programs written in different languages (Java, C, and JavaScript). In addition, \textbf{Comma Operator}, and \textbf{Assignment as Value} have been shown to be atoms in both of our experiments and in the study of Gopstein et al.\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}. 
Two code patterns have caused confusion in the participants of one of our experiments and also in one prior study, \textbf{Indentation No Braces}~\cite{Langhout:2021:ACJ} and \textbf{Implicit Predicate}~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}. 

Our interviews and the study of Langhout and Aniche~\cite{Langhout:2021:ACJ} have also analyzed the propensity of some of the atoms to induce confusion from a qualitative perspective, by asking developers about their preferences. In both cases, the obfuscated versions of \textbf{Omitted Curly Braces}, \textbf{Pre-Increment}, \textbf{Post-Increment}, \textbf{Implicit Predicate} were considered more confusing than their clean counterparts. Furthermore, the interview results are aligned with the experimental results: the clean versions were consistently considered less confusing than the obfuscated ones, except for one code pattern, Conditional Operator, which has not been confirmed as an atom by either of our experiments. 

Considering the accumulated evidence for the aforementioned atoms, not only in terms of statistical significance but also effect sizes, it is reasonable to suggest that coding style guides avoid them if they aim to cater to a wide range of developer experience levels. These guides usually exist in contexts where multiple developers need to maintain the same codebase and they aim to promote uniformity\footnote{https://google.github.io/styleguide/} and readability\footnote{https://github.com/airbnb/javascript}. Although personal preference and development experience have an impact on individual developers' ability to understand these code patterns, this is arguably not the audience that coding style guides should target. 

In the repeated measures study, we identified one JavaScript-specific atom, Object Destructuring. In the Latin square study, Automatic Semicolon Insertion was identified as another JavaScript-specific atom. For both cases, p-values were much lower than the threshold and effect sizes were high. However, in the repeated measures study obfuscated versions of Automatic Semicolon Insertion were not significantly different from their clean counterparts. Our interviewees favored the use of semicolon over Automatic Semicolon Insertion. Finally, as discussed in Section~\ref{sec:repeated:correct}, Array Destructuring exhibited a large effect size, in spite of the non-statistically significant difference (after correction). As discussed elsehwere~\cite{Ellis:2010:EGE}, this is a scenario that hints at practical relevance, specially considering the very low p-value ($< 0.003$). Further studies investigating these code patterns, potentially using different response variables~\cite{Oliveira:2020:ECR,Feitelson:2021:CPC}, are left for future work. 

Some code patterns that have been identified as atoms in previous work were not confirmed in our experiments, at least from a correctness perspective. Comparing the results of the Latin square study to previous research, two atoms of confusion that Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} confirmed for \clang and \cpplang do not lead to a statistically significant impact on correctness in our study, Logic as Control Flow, and Conditional Operator. Conditional Operator was the only atom candidate in our interviews whose obfuscated version was considered less confusing than the corresponding clean version. 

Logic as Control Flow is a more interesting case. Considering the correctness perspective, none of our experiments has identified Logic as Control Flow as an atom of confusion. However, in the Latin square study there was a significant difference in the time required to make a correct prediction in favor of the clean version of this atom candidate, with a medium effect size. Furthermore, both Langhout and Aniche~\cite{Langhout:2021:ACJ} and Gopstein and colleagues~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} have identified it as an atom. Two other atoms have exhibited a statistically significant difference in time, in favor of their obfuscated versions (with a small effect size). One of them, Pre-Increment, has been confirmed as an atom of confusion in multiple experiments, i.e., participants are less confused by the clean versions. These conflicting results reinforce the importance of conducting experiments that consider multiple response variables~\cite{Oliveira:2020:ECR}. In addition, it is clear that factors such as the experience of the participants and the selection of code snippets can have considerable impact on the results of studies about code readability~\cite{Feitelson:2021:CPC}.

Altogether, we answer our first research question as follows. 

\begin{mh}
  {\bf Answer to RQ1:} Our experiments using repeated measures and the Latin square designs give evidence that some of the atom candidates in \clang and \cpplang programs that also exist in JavaScript correspond to a source of misunderstanding in
  JavaScript code. 
\end{mh}

The results of the interview study complement the understanding of atoms of confusion because the participants make clear the existence of a trade-off between code comprehension and other quality attributes. For instance, most of the participants prefer the version of the code with the Conditional Operator, even though they agree that its use might contribute to the misunderstanding of JavaScript code, particularly when novices are maintaining the codebase. The participants of the interview study also
mentioned other possible sources of misunderstanding in JavaScript,
including the use of prototype-based inheritance and nested call-backs (as discussed in Section~\ref{sec:interview-results}). Other JavaScript atom candidates include
Object Destructuring, Array Spread, Object Spread, and Type Conversion.
In summary, the results of the second study (interviews) allow
us to answer the second research question.

\begin{mh}
  {\bf Answer to RQ2:} The qualitative analysis of the
  interviews supports the results of our experiments---
  JavaScript developers most often agree that atoms of confusion compromise
  source code understanding. 
\end{mh}

%% \begin{mh}
%%   {\bf Answer to RQ3:} The qualitative analysis of the
%%   interviews suggests that specific JavaScript constructs might also correspond to atoms of
%%   confusion, including prototype inheritance and
%%   nested callbacks. 
%% \end{mh}

The results of the third study (mining open source
JavaScript repositories) provides evidence that,
although atoms of confusion compromise program
comprehension, they frequently appear in open
source JavaScript projects. In particular,
seven, out of 10 atoms considered
  in our study, appear in more than 50\% of
the 72 projects we analyzed. Furthermore, at least two of them are used intensively, more than once for every 200 lines of code. In summary, the third study
allows us to answer the third research
question.


\begin{mh}
  {\bf Answer to RQ3:} The MSR study reveals that
  several atom candidates explored in our research
  appear frequently in practice, and cleaning up the use of 
  Post-Increment/Decrement and the Automatic Semicolon Insertion
  might improve the readabiliy of JavaScript code substantially. 
\end{mh}



%% We conducted a non-exact replication of the three
%% studies (survey, interview, and mining software repositories)
%% considering these more specific JavaScript atom candidates.
%% We confirmed that they truly correspond to sources of misunderstanding.
%% Due to lack of space,
%% we cannot present all the results here, and we postpone the presentation of these results as future work.




\section{Discussion}
\label{sec:discussion}


% From the paper. I think it makes more sense to discuss this in the context of teh two studies. 
Comparing the results of the latin square study to previous research, three 
atoms of confusion that Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17} confirmed
for \clang and \cpplang do not lead to a statistically significant impact
on correctness in our study: Logic as Control Flow,
Conditional Operator, and Pre-Increment. Our results
support the Gopstein et al. findings for the remaining
atoms. The work of Langhout and Aniche~\cite{Langhout:2021:ACJ} investigates six atom candidates for Java that we also explore here for JavaScript. Among these atom
candidates, we achieve similar conclusions to their
study for four atom candidates: Post Increment,
Conditional Operator, Arithmetic as Logic, and
Omitted Curly Braces---both studies confirmed only the former
as an atom of confusion. Our findings diverged from
the work of Langhout and Aniche for two atoms: Pre Increment and
Logic as Control Flow.


\castor{Which atoms? The weight of experience. Statistical significance vs. practical relevance. Most of them, with the exception of Comma Operator and Object Destructuring, have also been observed for Java programs~\cite{Langhout:2021:ACJ}.

In addition, many of the coding idioms that have been previously identified as atoms of confusion in previous work~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17,Langhout:2021:ACJ}, such as Logic as Control Flow

Differences among the two studies, for example, post increment was not significant in the first one but it was significant in the second.
}

Our work has several implications.
First, it adds external validity to the
work of Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17},
which investigates
the impact of atom candidates on
understanding \clang,\cpplang code. That is,
similarly to their work, the atom candidates
Comma Operator, Post/Pre Increment, Omitted Curly Braces,
Assignment as Value, Implicit Predicate, and Logic as
Control Flow seem to make 
JavaScript code harder to understand. For five of them, the difference is statistically significant, with a large effect size for four atoms. Our results also 
refute the hypothesis that Arithmetic as Logic is an atom of confusion (i.e., a source of misunderstanding).
In comparison to the original
work of Gopstein et al.~\cite{DBLP:conf/sigsoft/GopsteinIYDZYC17}, 
our study
led to some differences in the effect size
of the atom candidates.
Altogether, we answer our first research question.

\begin{mh}
  {\bf Answer to RQ1:} Our experiments using repeated measures and the Latin square designs give evidence that some of the atom candidates in \clang and \cpplang programs that also exist in JavaScript correspond to a source of misunderstanding in
  JavaScript code. 
\end{mh}

The results of the interview study complement the understanding of atoms of confusion because the participants make clear the existence of a trade-off between code comprehension and other quality attributes. For instance, most of the participants prefer the version of the code with the Conditional Operator, even though they agree that its use might contribute to the misunderstanding of JavaScript code, particularly when novices are maintaining the codebase. The participants of the interview study also
mentioned other possible sources of misunderstanding in JavaScript,
including the use of prototype-based inheritance and nested call-backs (as discussed in Section~\ref{sec:interview-results}). Other JavaScript atom candidates include
Object Destructuring, Array Spread, Object Spread, and Type Conversion.
In summary, the results of the second study (interviews) allow
us to answer the second research question.

\begin{mh}
  {\bf Answer to RQ2:} The qualitative analysis of the
  interviews supports the results of our experiments---
  JavaScript developers most often agree that atoms of confusion compromise
  source code understanding. 
\end{mh}

%% \begin{mh}
%%   {\bf Answer to RQ3:} The qualitative analysis of the
%%   interviews suggests that specific JavaScript constructs might also correspond to atoms of
%%   confusion, including prototype inheritance and
%%   nested callbacks. 
%% \end{mh}

The results of the third study (mining open source
JavaScript repositories) provides evidence that,
although atoms of confusion compromise program
comprehension, they frequently appear in open
source JavaScript projects. In particular,
seven, out of 10 atoms considered
  in our study, appear in more than 50\% of
the 72 projects we analyzed. Furthermore, at least two of them are used intensively, more than once for every 200 lines of code. In summary, the third study
allows us to answer the third research
question.


\begin{mh}
  {\bf Answer to RQ3:} The MSR study reveals that
  several atom candidates explored in our research
  appear frequently in practice, and cleaning up the use of 
  Post-Increment/Decrement and the Automatic Semicolon Insertion
  might improve the readabiliy of JavaScript code substantially. 
\end{mh}



%% We conducted a non-exact replication of the three
%% studies (survey, interview, and mining software repositories)
%% considering these more specific JavaScript atom candidates.
%% We confirmed that they truly correspond to sources of misunderstanding.
%% Due to lack of space,
%% we cannot present all the results here, and we postpone the presentation of these results as future work.



